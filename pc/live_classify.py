#!/usr/bin/env python3
import argparse
import json
import math
import socket
import struct
import time
from collections import deque
from pathlib import Path

from dtw_baseline import (
    LabeledSequence,
    calibrate_label_thresholds,
    compute_query_scores,
    load_labeled_sequences,
    predict_with_rejection,
    prep_sequence,
    read_manifest,
)

FMT = "<q6h"
SIZE = struct.calcsize(FMT)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Live IMU action detection + classification from UDP stream."
    )
    parser.add_argument("--host", default="0.0.0.0", help="UDP bind host")
    parser.add_argument("--port", type=int, default=9000, help="UDP bind port")
    parser.add_argument(
        "--model",
        type=Path,
        default=Path("data/model/action_model.json"),
        help="Offline model artifact generated by build_model.py",
    )
    parser.add_argument(
        "--build-on-start",
        action="store_true",
        help="If model is missing, build it from manifest at startup (slow)",
    )
    parser.add_argument(
        "--manifest",
        type=Path,
        default=Path("data/labels/manifest.jsonl"),
        help="Manifest path used only when --build-on-start is enabled",
    )
    parser.add_argument("--session", default="", help="Manifest session filter")
    parser.add_argument("--labels", default="", help="Manifest label filter")
    parser.add_argument("--mode", choices=("trigger", "fixed"), default="trigger")
    parser.add_argument(
        "--duration-sec",
        type=float,
        default=2.2,
        help="Capture window in fixed mode",
    )
    parser.add_argument(
        "--trigger-on",
        type=float,
        default=800.0,
        help="Gyro norm threshold to trigger action start",
    )
    parser.add_argument(
        "--trigger-off",
        type=float,
        default=300.0,
        help="Gyro norm threshold for action end",
    )
    parser.add_argument(
        "--trigger-on-hold",
        type=int,
        default=3,
        help="Consecutive above-threshold samples to confirm action start",
    )
    parser.add_argument(
        "--trigger-off-hold",
        type=int,
        default=20,
        help="Consecutive below-threshold samples to confirm action end",
    )
    parser.add_argument(
        "--pre-sec",
        type=float,
        default=0.25,
        help="Pre-trigger history to include",
    )
    parser.add_argument(
        "--post-sec",
        type=float,
        default=0.25,
        help="Post-end tail to include",
    )
    parser.add_argument(
        "--min-action-sec",
        type=float,
        default=0.15,
        help="Minimum action duration before end condition is accepted",
    )
    parser.add_argument(
        "--max-action-sec",
        type=float,
        default=2.5,
        help="Maximum action duration",
    )
    parser.add_argument(
        "--max-wait-sec",
        type=float,
        default=6.0,
        help="Maximum wait for trigger in trigger mode",
    )
    parser.add_argument(
        "--drain-max-packets",
        type=int,
        default=50000,
        help="Maximum packets to drain before each capture",
    )
    parser.add_argument("--k", type=int, default=5, help="Top-k neighbors to print")
    parser.add_argument(
        "--once",
        action="store_true",
        help="Run one capture/inference and exit",
    )

    # Fallback model-build knobs (used only when --build-on-start).
    parser.add_argument("--max-points", type=int, default=180)
    parser.add_argument("--no-znorm", action="store_true")
    parser.add_argument("--window-frac", type=float, default=0.2)
    parser.add_argument("--per-label-k", type=int, default=3)
    parser.add_argument("--score-mode", choices=("dtw", "hybrid", "xcorr"), default="hybrid")
    parser.add_argument("--hybrid-alpha", type=float, default=0.35)
    parser.add_argument("--xcorr-max-lag-frac", type=float, default=0.15)
    parser.add_argument("--xcorr-min-overlap-frac", type=float, default=0.50)
    parser.add_argument("--reject-quantile", type=float, default=1.0)
    parser.add_argument("--reject-scale", type=float, default=1.10)
    parser.add_argument("--reject-margin", type=float, default=1.03)
    parser.add_argument("--reject-threshold-grace", type=float, default=1.03)
    parser.add_argument("--unknown-label", default="unknown")
    return parser.parse_args()


def drain_socket(sock: socket.socket, max_packets: int) -> int:
    drained = 0
    old_timeout = sock.gettimeout()
    sock.setblocking(False)
    try:
        while drained < max_packets:
            try:
                sock.recvfrom(2048)
                drained += 1
            except BlockingIOError:
                break
    finally:
        sock.setblocking(True)
        sock.settimeout(old_timeout)
    return drained


def recv_sample(sock: socket.socket) -> tuple[int, tuple[float, ...], float] | None:
    try:
        data, _addr = sock.recvfrom(2048)
    except socket.timeout:
        return None
    if len(data) < SIZE:
        return None
    ts_us, ax, ay, az, gx, gy, gz = struct.unpack(FMT, data[:SIZE])
    feat = (float(ax), float(ay), float(az), float(gx), float(gy), float(gz))
    gyro_norm = math.sqrt(gx * gx + gy * gy + gz * gz)
    return ts_us, feat, gyro_norm


def capture_fixed_by_ts(sock: socket.socket, duration_sec: float) -> list[tuple[float, ...]]:
    duration_us = int(duration_sec * 1_000_000)
    seq: list[tuple[float, ...]] = []
    start_ts_us: int | None = None
    last_ts_us: int | None = None

    while True:
        sample = recv_sample(sock)
        if sample is None:
            continue
        ts_us, feat, _energy = sample
        if start_ts_us is None:
            start_ts_us = ts_us
            last_ts_us = ts_us

        if ts_us < last_ts_us:
            continue
        last_ts_us = ts_us
        if ts_us - start_ts_us > duration_us:
            break
        seq.append(feat)
    return seq


def capture_triggered(
    sock: socket.socket,
    trigger_on: float,
    trigger_off: float,
    trigger_on_hold: int,
    trigger_off_hold: int,
    pre_sec: float,
    post_sec: float,
    min_action_sec: float,
    max_action_sec: float,
    max_wait_sec: float,
    expected_hz: float,
) -> list[tuple[float, ...]]:
    pre_len = max(1, int(round(pre_sec * expected_hz)))
    pre_buf: deque[tuple[int, tuple[float, ...], float]] = deque(maxlen=pre_len)
    on_count = 0
    wait_deadline = time.monotonic() + max_wait_sec if max_wait_sec > 0 else float("inf")
    last_ts_us: int | None = None

    # Wait for onset.
    while time.monotonic() < wait_deadline:
        sample = recv_sample(sock)
        if sample is None:
            continue
        ts_us, feat, energy = sample
        if last_ts_us is not None and ts_us < last_ts_us:
            continue
        last_ts_us = ts_us
        pre_buf.append(sample)
        if energy >= trigger_on:
            on_count += 1
        else:
            on_count = 0
        if on_count >= max(1, trigger_on_hold):
            break
    else:
        return []

    # Start capture from pre-trigger buffer.
    seq_samples = list(pre_buf)
    trigger_ts_us = seq_samples[-1][0]
    off_count = 0
    min_action_us = int(min_action_sec * 1_000_000)
    max_action_us = int(max_action_sec * 1_000_000)
    post_us = int(post_sec * 1_000_000)
    post_until_us: int | None = None

    while True:
        sample = recv_sample(sock)
        if sample is None:
            continue
        ts_us, feat, energy = sample
        if ts_us < seq_samples[-1][0]:
            continue
        seq_samples.append((ts_us, feat, energy))
        elapsed = ts_us - trigger_ts_us

        if post_until_us is not None:
            if ts_us >= post_until_us:
                break
            continue

        if elapsed >= max_action_us:
            break

        if energy <= trigger_off:
            off_count += 1
        else:
            off_count = 0

        if elapsed >= min_action_us and off_count >= max(1, trigger_off_hold):
            post_until_us = ts_us + post_us

    return [x[1] for x in seq_samples]


def load_model(model_path: Path) -> tuple[list[LabeledSequence], dict, dict[str, float]]:
    with model_path.open("r", encoding="utf-8") as f:
        obj = json.load(f)
    refs = [
        LabeledSequence(
            label=x["label"],
            path=Path(x["path"]),
            seq=[tuple(float(v) for v in p) for p in x["seq"]],
        )
        for x in obj["references"]
    ]
    params = obj["params"]
    thresholds = {k: float(v) for k, v in obj.get("thresholds", {}).items()}
    return refs, params, thresholds


def build_runtime_from_manifest(args: argparse.Namespace) -> tuple[list[LabeledSequence], dict, dict]:
    labels = {x.strip().lower() for x in args.labels.split(",") if x.strip()}
    rows = read_manifest(args.manifest, session=args.session, labels=labels)
    if not rows:
        raise ValueError("no reference samples selected from manifest")

    use_znorm = not args.no_znorm
    refs = load_labeled_sequences(rows, max_points=args.max_points, use_znorm=use_znorm)
    params = {
        "max_points": args.max_points,
        "use_znorm": use_znorm,
        "window_frac": args.window_frac,
        "per_label_k": args.per_label_k,
        "score_mode": args.score_mode,
        "hybrid_alpha": args.hybrid_alpha,
        "xcorr_max_lag_frac": args.xcorr_max_lag_frac,
        "xcorr_min_overlap_frac": args.xcorr_min_overlap_frac,
        "reject_margin": args.reject_margin,
        "reject_threshold_grace": args.reject_threshold_grace,
        "unknown_label": args.unknown_label,
    }
    thresholds = calibrate_label_thresholds(
        refs,
        window_frac=args.window_frac,
        per_label_k=args.per_label_k,
        q=args.reject_quantile,
        scale=args.reject_scale,
        score_mode=args.score_mode,
        hybrid_alpha=args.hybrid_alpha,
        xcorr_max_lag_frac=args.xcorr_max_lag_frac,
        xcorr_min_overlap_frac=args.xcorr_min_overlap_frac,
    )
    return refs, params, thresholds


def main() -> int:
    args = parse_args()
    if args.k <= 0:
        raise ValueError("--k must be > 0")
    if args.duration_sec <= 0:
        raise ValueError("--duration-sec must be > 0")
    if args.trigger_on < 0 or args.trigger_off < 0:
        raise ValueError("trigger thresholds must be >= 0")
    if args.trigger_on < args.trigger_off:
        raise ValueError("--trigger-on must be >= --trigger-off")

    t0 = time.perf_counter()
    if args.model.exists():
        refs, params, thresholds = load_model(args.model)
        source = f"model:{args.model}"
    elif args.build_on_start:
        print("model missing; building from manifest (slow)...")
        refs, params, thresholds = build_runtime_from_manifest(args)
        source = f"manifest:{args.manifest}"
    else:
        raise FileNotFoundError(
            f"model not found: {args.model}. Run pc/build_model.py first or use --build-on-start."
        )
    t1 = time.perf_counter()

    print(f"loaded references={len(refs)} labels={sorted({x.label for x in refs})}")
    print(f"source={source}")
    print(f"startup_sec={t1 - t0:.3f}")
    print(
        "runtime_config: "
        f"mode={args.mode} score_mode={params['score_mode']} "
        f"max_points={params['max_points']} use_znorm={params['use_znorm']}"
    )

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind((args.host, args.port))
    sock.settimeout(0.25)
    print(f"listening on {args.host}:{args.port}")

    while True:
        if not args.once:
            cmd = input("Press Enter to capture or type q to quit: ").strip().lower()
            if cmd in {"q", "quit", "exit"}:
                break

        drained = drain_socket(sock, max_packets=args.drain_max_packets)
        if drained > 0:
            print(f"drained {drained} stale packets")

        if args.mode == "fixed":
            print(f"capturing fixed window {args.duration_sec:.2f}s by device timestamp...")
            raw_seq = capture_fixed_by_ts(sock, duration_sec=args.duration_sec)
        else:
            print(
                "waiting trigger "
                f"(on={args.trigger_on:.1f}, off={args.trigger_off:.1f}, "
                f"max_wait={args.max_wait_sec:.1f}s)..."
            )
            raw_seq = capture_triggered(
                sock=sock,
                trigger_on=args.trigger_on,
                trigger_off=args.trigger_off,
                trigger_on_hold=args.trigger_on_hold,
                trigger_off_hold=args.trigger_off_hold,
                pre_sec=args.pre_sec,
                post_sec=args.post_sec,
                min_action_sec=args.min_action_sec,
                max_action_sec=args.max_action_sec,
                max_wait_sec=args.max_wait_sec,
                expected_hz=316.0,
            )

        if not raw_seq:
            print("no actionable window captured")
            if args.once:
                return 1
            continue

        query = prep_sequence(
            raw_seq,
            max_points=int(params["max_points"]),
            use_znorm=bool(params["use_znorm"]),
        )
        label_scores, dtw_scores, xcorr_scores, pair_metrics = compute_query_scores(
            query,
            refs,
            window_frac=float(params["window_frac"]),
            per_label_k=int(params["per_label_k"]),
            score_mode=str(params["score_mode"]),
            hybrid_alpha=float(params["hybrid_alpha"]),
            xcorr_max_lag_frac=float(params["xcorr_max_lag_frac"]),
            xcorr_min_overlap_frac=float(params["xcorr_min_overlap_frac"]),
        )
        pred, reject_reason = predict_with_rejection(
            label_scores=label_scores,
            thresholds=thresholds,
            margin=float(params["reject_margin"]),
            threshold_grace=float(params["reject_threshold_grace"]),
            unknown_label=str(params["unknown_label"]),
        )

        print(f"prediction={pred} samples={len(raw_seq)}")
        if reject_reason:
            print(f"reject_reason={reject_reason}")
        print(f"score_mode={params['score_mode']}")
        print("label_scores (final | dtw | xcorr):")
        for label, score in sorted(label_scores.items(), key=lambda x: x[1]):
            print(
                f"- {label}: {score:.4f} | "
                f"{dtw_scores.get(label, float('nan')):.4f} | "
                f"{xcorr_scores.get(label, float('nan')):.4f}"
            )
        k = max(1, min(args.k, len(pair_metrics)))
        for rank, m in enumerate(pair_metrics[:k], start=1):
            print(
                f"{rank}. label={m.label} dist={m.dtw:.4f} xcorr={m.xcorr:.4f} "
                f"lag={m.lag} ref={m.path}"
            )

        if args.once:
            return 0
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
